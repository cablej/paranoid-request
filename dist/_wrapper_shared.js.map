{"version":3,"sources":["../src/_wrapper_shared.js"],"names":["safeModuleWrapper","oldModule","connectionFunc","newModule","Object","getOwnPropertyNames","forEach","name","Agent","options","prototype","createConnection","safeConnectionWrapper","addrValidator","JSON","stringify","request","safeRequestWrapper","get","cb","req","end","globalAgent","isParanoid","needLocalAddressHack","lt","process","version","fn","safeRequestWrappedFn","parse","_extend","agent","_defaultAgent","socketPath","stubSocketError","UnacceptableAddressError","localAddress","undefined","Error","call","err","sock","Socket","connect","nextTick","destroy","wrappingSafeConnect","safeConnectionWrappedFn","args","_normalizeArgs","arguments","isSafePort","port","resolved","dnsErr","newOptions","lookupOpts","safeLookup","host","address","family","require","loopWhile","apply","sanitizeAddresses","addresses","map","toString","toBuffer","filter","isSafeIP","bind","defaults","all","optionsArg","lookupService","lookup","length","sanitizedAddresses"],"mappings":"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","file":"_wrapper_shared.js","sourcesContent":["// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* globals process */\n\nimport dns from 'dns';\nimport net from 'net';\nimport url from 'url';\nimport util from 'util';\nimport deepcopy from 'deepcopy';\nimport ip from 'ip';\nimport semver from 'semver';\nimport errors from './errors';\nimport AddrValidator from './addr_validator';\n\n// Wraps one of the stdlib's HTTP(S)? modules to do paranoid checks on connect.\nconst safeModuleWrapper = (oldModule, connectionFunc) => {\n  // Copy the inner modules props to us\n  // TODO: create properties that read from the inner module until mutation?\n  const newModule = {};\n\n  Object.getOwnPropertyNames(oldModule).forEach(name => {\n    newModule[name] = oldModule[name];\n  });\n\n  class Agent extends oldModule.Agent {\n    constructor(options) {\n      super(options);\n      // In Node 0.10 `createConnection` is set on the instance in the constructor\n      // only add it here if we really need to.\n      if (!oldModule.Agent.prototype.createConnection) {\n        this.createConnection = connectionFunc || safeConnectionWrapper(this.createConnection);\n      }\n    }\n\n    getName(options) {\n      // Give our instances a unique name to make sure we don't share a pool\n      // with non-paranoid connections\n      let name = super.getName(options);\n      name += ':paranoid!';\n      if (options.addrValidator) {\n        name += ':';\n        name += JSON.stringify(options.addrValidator);\n      }\n      return name;\n    }\n  }\n\n  if (Agent.prototype.createConnection) {\n    Agent.prototype.createConnection = connectionFunc ||\n      safeConnectionWrapper(Agent.prototype.createConnection);\n  }\n\n  newModule.Agent = Agent;\n  newModule.request = safeRequestWrapper(newModule, oldModule.request);\n  newModule.get = (options, cb) => {\n    const req = newModule.request(options, cb);\n    req.end();\n    return req;\n  };\n\n  newModule.globalAgent = new Agent();\n  newModule.isParanoid = true;\n  return newModule;\n};\n\nconst needLocalAddressHack = semver.lt(process.version, '0.11.0');\n\n// Wraps around <module>.request to make sure our agent gets used\nfunction safeRequestWrapper(newModule, fn) {\n  return function safeRequestWrappedFn(options, cb) { // eslint-disable-line max-statements\n    if (typeof options === 'string') {\n      options = url.parse(options);\n    } else {\n      options = util._extend({}, options);\n    }\n\n    if (!options.addrValidator) {\n      options.addrValidator = new AddrValidator();\n    } else {\n      // This is included in the conn pool key, so we need to be\n      // safe against idiots like me mutating it after the original\n      // request!\n      options.addrValidator = new AddrValidator(deepcopy(options.addrValidator));\n    }\n    // No connection pooling, create an agent just for this\n    // request.\n    if (options.agent === false) {\n      options.agent = new newModule.Agent();\n      // otherwise falsy agent, use the global one for the module\n    } else if (!options.agent) {\n      options.agent = newModule.globalAgent;\n    }\n\n    if (!options._defaultAgent) {\n      options._defaultAgent = new newModule.Agent();\n    }\n\n    if (options.socketPath) {\n      // Node < 0.12 won't use the agent's `createConnection` and has\n      // wonky behaviour if you set `options.createConnection`. Try to\n      // catch this here instead.\n      return stubSocketError(new errors.UnacceptableAddressError(\n        'UNIX domain sockets are not allowed'\n      ));\n    }\n\n    // Great, Node 0.10 won't let us pass arbitrary options down to\n    // `createConnection()`. Hack around that by smuggling it through\n    // the `localAddress` option (which an HTTP client won't use)\n    if (needLocalAddressHack && options.addrValidator) {\n      if (options.localAddress !== undefined) {\n        throw new Error('Can\\'t use validator param hack with defined localAddress!');\n      }\n      options.localAddress = options.addrValidator;\n    }\n    return fn.call(this, options, cb); // eslint-disable-line no-invalid-this\n  };\n}\n\n// A stupid hack around request not being able to handle\n// errors thrown during the synchronous part of socket setup.\n// return a socket whose only purpose is to give async errors\n// see https://github.com/request/request/issues/1946\nfunction stubSocketError(err) {\n  const sock = new net.Socket();\n  sock.connect = null;\n  // Give the caller time to register their error listeners.\n  process.nextTick(() => {\n    sock.destroy(err);\n  });\n  return sock;\n}\n\n// Wraps around net.createConnection()\nfunction safeConnectionWrapper(fn, wrappingSafeConnect) {\n  // Does the function that we're wrapping handle its own DNS lookups? If so, we don't\n  // need to do our always-safe blocking lookup.\n  wrappingSafeConnect = (wrappingSafeConnect || false);\n\n  return function safeConnectionWrappedFn() { // eslint-disable-line max-statements\n    const args = net._normalizeArgs(arguments);\n    const options = args[0];\n\n    // We smuggled our validator through localAddress\n    if (options.localAddress instanceof AddrValidator) {\n      options.addrValidator = options.localAddress;\n      options.localAddress = undefined;\n    }\n    if (!options.addrValidator) {\n      options.addrValidator = new AddrValidator();\n    }\n\n    // It won't use TCP/IP, It's a unix domain socket. Exterminate.\n    if (options.socketPath) {\n      return stubSocketError(new errors.UnacceptableAddressError(\n        'UNIX domain sockets are not allowed'\n      ));\n    }\n\n    if (!options.addrValidator.isSafePort(options.port)) {\n      return stubSocketError(new errors.UnacceptableAddressError(\n        'Disallowed port detected'\n      ));\n    }\n    // So here's the skinny. Normally `.createConnection()` and co create the socket,\n    // then return the created socket while the hostname lookup and connection attempt\n    // happen in the background. No problem, `net.Socket.connect` accepts a `lookup` option\n    // with a function to use instead of `dns.lookup` so we can filter records!\n    //\n    // Unfortunately, it never calls it if the address looks like an IP, and\n    // `tls.connect` doesn't honor it at all. The `http` module basically just calls out to\n    // the super-simple and stable `net.createConnection` function, so we can just rewrite that\n    // entirely.\n    //\n    // The `https` module, however, has a very unstable implementation as does the underlying `tls`\n    // module. Neither gives us an easy way to either use our own socket, or make a lookup happen\n    // before the `connect()` call.\n    //\n    // Rather than detect node versions and use a different hacked up version of the tls module\n    // based on Node version, let's just do a synchronous DNS lookup\n    // if we can't easily do it asynchronously.\n    if (!wrappingSafeConnect) {\n      let resolved = false;\n      let dnsErr = null;\n      const newOptions = util._extend({}, options);\n      const lookupOpts = {addrValidator: options.addrValidator};\n      safeLookup(options.host, lookupOpts, (err, address, family) => {\n        // Connect to the resolved IP when we call `sock.connect()` to avoid TOCTOU vulns\n        // via DNS rebinding.\n        newOptions.host = address;\n        args[0] = newOptions;\n        dnsErr = err;\n        resolved = true;\n      });\n      // Sit around while we wait for the lookup to complete\n      require('deasync').loopWhile(() => !resolved);\n      if (dnsErr) {\n        return stubSocketError(dnsErr);\n      }\n    }\n    // Call our wrapped `createConnection()`\n    return fn.apply(this, args); // eslint-disable-line no-invalid-this\n  };\n}\n\nfunction sanitizeAddresses(addresses, addrValidator) {\n  return addresses\n    .map(address => ip.toString(ip.toBuffer(address.address)))\n    .filter(addrValidator.isSafeIP.bind(addrValidator));\n}\n\nfunction safeLookup(host, options, cb) {\n  const defaults = {\n    // No love for RFC1918 in IPv6-land == no safety via this lib.\n    family: 4,\n    all: true\n  };\n\n  options = util._extend(defaults, options);\n\n  let optionsArg = options;\n  // Looks like we have an older version of the DNS API, it expects a plain\n  // 'ol family number for the second arg.\n  if (!dns.lookupService) {\n    optionsArg = options.family;\n  }\n  dns.lookup(host, optionsArg, (err, addresses, family) => {\n    if (err || !addresses || !addresses.length) {\n      return cb(err, null, family);\n    }\n\n    // Some versions of node don't care that we want _all_ addresses.\n    if (typeof addresses === 'string') {\n      addresses = [{address: addresses, family}];\n    }\n\n    const sanitizedAddresses = sanitizeAddresses(addresses, options.addrValidator);\n\n    let address = {address: null, family: options.family};\n\n    if (sanitizedAddresses.length) {\n      address = addresses[0];\n    } else {\n      err = new errors.UnacceptableAddressError('All addresses were blacklisted!');\n    }\n\n    return cb(err, address.address, address.family);\n  });\n}\n\nexport default {\n  safeLookup,\n  safeConnectionWrapper,\n  safeModuleWrapper,\n  sanitizeAddresses\n};\n"]}